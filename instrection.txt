1. install nest globally by npm i -g @nestjs/cli
2. Create a new app by nest new project_name

3. Controllers
    - Controllers are classes defined with @controller decorator
    - Controllers are responsible for incoming user request and response
    - bounded to single api path
    - Controllers contains handlers which handles endpoints and req. methods like get, post, put delete patch
    - can take advantages of dependency injections
    - defined with decorator @controller
    - Defining a controller nest g controller controller_name --no-spec

5. Handlers
    - Handlers are methods in classes which handles the endpoint

6. Modules
    - Modules are starting point of the application 
    - Each app will contain at least one Modules
    - Modules are effective ways to organize components by a closely related set of capabilities
    - Modules have following properties controllers, providers, imports, exports
    - Defining a Module nest g Module Module_name

7. Providers
    - providers can be injected into controllers if decorated as @Injectable
    - provides can be anything a class, value, sync/async values
    - provides must be provide to models in order to access in controllers
    - can be exported from a model to another module and imported in required modules

8. Services
    - Services are implemented using providers
    - Not all providers are services
    - contains business logics
    - Created using nest g service --no-spec

9. Dependency injection
    - Any component in nest js can be imported as Dependency if they are decorated with @injectables
    - We define the dependency in the constructor of the class and nest will take care of it and will be available in the class property

10. Whenever we need to create a new element we need a model or schema for it
    - We can have a ts interface or class

11. DTO - Data Tranfer Object
    - It is common in software programming not specific to nest.js
    - result is more bulletproof since it can be used as a ts type
    - do not have specific behavior except storng , retriving, serilization and deserilization of Data
    - results in incrased performance
    - useful for datavalidation 
    - it is not a model definition. it defies the shape of the data
    - can be created using a interface or a class
    - it defines the structure for the icomming data from th euser request and allows us to use it all over the app
12. Piping
    - pipes operate on the arguments to be processed by the handlers before the handlers are called 
    - pipes can perform data-transformation and data-validation
    - pipes can return data modified or originally which will be passed to the route handlers
    - pipes can through exceptions nestjs will handle the exception and process it into errors
    - pipes can be async
13. Default pipes in nestjs
    - nestjs has one default pipes in nestjs/common
        - validation pipes - compairs the incomming objects against the classes and handles to the route handler if one property doesint match then it will through a exception
        - parseint pipe - every incomming arguments will be a string it will convert it into string
14. custome pipes
    - pipes are classes that can be defined using @Injestable decorator
    - pipes implement the PIPE TRANSFORM INTERFACE
    - therefore every pipe must have a transform() method this method will be called by the nestjs to process the arguments
    - the transform method will accepts two arguments
        - value() - the value of the processed arguments
        - metadata() - object containing metadata about the objet 
    -  whatever returned from this method will be sent to the route handler and the exceptions are sent to the client
    three types of pipes 

        handler level pipes                        params level pipes                      global level pipes

     requires some additional code          tends to slimmer and cleaner however
     but provides some more additional      results in extra code for handler and
     benifits                               becomes messy and hard to handle

     - such pipes does not require extracode at the perameter level
     - easy to make some change if there is some change in the datatype since it is only nedded to make changes in pipes
     - the responsibility of identifing the arguments to the process is shifter to the pipe file
     - promotes use of DTO which is very good practice
15. validation
    - in order to add validation we need to install npm i class-validator class-transformer
    - find the avliable decerators in the class validator https://github.com/typestack/class-validator  